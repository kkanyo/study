---
tags:
  - operating_system
---
### 식사하는 철학자 문제(dining philosophers problem)
교착 상태를 설명하기 위한 문제 상황이다.

```
동그란 원탁에 다섯 명의 철학자가 앉아 있다.
철학자들 앞에는 맛있는 식사가 있고, 철학자들 사이 사이에는 식사에 필요한 포크가 있다.
철학자들 앞에 있는 식사는 두 개의 포크로 먹을 수 있는 음식이라고 가정한다.

철학자들은 아래와 같은 순서로 식사를 한다.
1. 왼쪽 포크가 사용 가능하면 집어든다.
2. 오른쪽 포크가 사용 가능하면 집어든다.
3. 왼쪽과 오른쪽 포크를 모두 집어들면 정해진 시간동안 식사를 한다.
4. 식사 시간이 끝나면 오른쪽 포크를 내려놓는다.
5. 오른쪽 포크를 내려놓은 뒤 왼쪽 포크를 내려놓는다.
6. 다시 1번부터 반복한다.

모든 철학자가 동시에 포크를 집어 식사를 하면 어떤 철학자도 식사를 할 수 없고 영원히 기다리는 상황이 발생할 수 있다.
다시 말해 모든 철학자는 다른 철학자가 포크를 내려놓을 때까지 기다린다.
```

### 교착 상태(deadlock)
일어나지 않을 사건을 기다리며 진행이 멈춰 버리는 현상을 말한다.

뮤텍스 락에서도 교착 상태는 발생할 수 있다.
```c++
lock1 = true;
while(lock2 == true)
;
// 임계 구역 작업
lock1 = false;
```
```c++
lock2 = true;
while(lock1 == true)
;
// 임계 구역 진입
lock2 = false;
```
예를 들어 프로세스 A는 임계 구역 진입 전 lock1을 잠그고, 프로세스 B는 임계 구역 진입 전 lock2를 잠근다고 가정한다.
만일 프로세스 A는 lock2가 false가 되길 기다리고, 프로세스 B는 lock1이 false가 되길 기다린다면 교착 상태가 발생한다.

#### 자원 할당 그래프(resource-allocation graph)
어떤 프로세스가 어떤 자원을 사용하고 있고, 기다리고 있는지를 표현하는 간단한 그래프이다.

아래와 같은 규칙으로 그려진다.
- 프로세스는 원으로, 자원의 종류는 사각형으로 표현한다.
- 사용할 수 있는 자원의 개수는 자원 사각형 내에 점으로 표현한다.
  같은 자원이라 할지라도 사용 가능한 자원의 개수는 여러 개 있을 수 있다.
- 프로세스가 어떤 자원을 할당받아 사용 중이라면 자원에서 프로세스를 향해 화살표를 표시한다.
  프로세스가 자원 이용을 끝내고 운영체제에 자원을 반납하면 화살표를 삭제된다.
- 프로세스가 어떤 자원을 기다리고 있다면 프로세스에서 자원으로 화살표를 표시한다.
![[os_race-condition_resource-allocation-graph.png]]

식사하는 철학자 문제를 자원 할당 그래프로 표현하면 아래와 같다.
![[os_race-condition_resource-allocation-graph_race-condition.png]]
즉, 교착 상태가 발생한 상황은 자원 할당 그래프가 원의 형태를 띄고 있다.

#### 교착 상태 발생 조건
교착 상태가 발생할 조건에는 상호 배제, 점유와 대기, 비선점, 원형 대기 네 가지가 있다.
이 조건들이 모두 만족될 때 교착 상태가 발생할 ==가능성이 생긴다.==

##### 상호 배제(mutual exclusion)
하나의 프로세스가 사용하는 자원을 다른 프로세스가 사용할 수 없을 때, 즉 상호 배제 상황에서 교착 상태가 발생할 수 있다.

##### 점유와 대기(hold and wait)
자원을 할당받은 상태에서 다른 자원을 할당받기를 기다리는 상태를 말한다.

##### 비선점(non-preemptive)
어떤 프로세스도 다른 프로세스의 자원을 강제로 빼앗기 못하는 것을 말한다.

##### 원형 대기(circular wait)
프로세스들이 원의 형태로 자원을 대기하는 것을 말한다.
> [!note] 원의 형태를 띈다고 해서 반드시 교착 상태가 발생하는 것은 아니다.

***
### 교착 상태 해결 방법

#### 교착 상태 예방
교착 상태 발생 필요 조건 네 가지 중 하나를 충족하지 못하게 하는 방법이다.
교착 상태가 발생하지 않음을 보장할 수는 있지만 여러 부작용이 따른다.

##### 상호 배제
상호 배제는 없앤다는 것은 모든 자원을 공유 가능하게 만든다는 것과 동일하다.
이론적으로는 가능하지만, 현실적으로 모든 자원의 상호 배제를 없애기는 어렵기 때문에 무리가 있다.

##### 점유와 대기
특정 프로세스에 자원을 모두 할당하거나, 아예 할당하지 않는 방식으로 배분한다.
하지만 당장 자원이 필요해도 기다릴 수밖에 없는 프로세스와 사용되지 않으면서 오랫동안 할당되는 자원을 다수 양상하기 때문에 자원 활용률이 낮아진다.
많은 자원을 필요로 하는 프로세스가 무한정 기다리게 되는 기아 현상을 야기할 우려가 있다.

##### 비선점 조건
선점하여 사용할 수 있는 일부 자원에 대해서는 효과적이지만, 모든 자원이 선점 가능한 것은 아니다.
다소 범용성이 떨어지는 방식이다.

##### 원형 조건
모든 자원에 번호를 붙이고, 오름차순으로 자원을 할당하면 원형 대기는 발생하지 않는다.
하지만 모든 컴퓨터 시스템 내에 존재하는 수많은 자원에 번호를 붙이는 일은 비효율적이고, 각 자원에 어떤 번호를 붙이는지에 따라 특정 자원의 활용률이 떨어질 수 있다.


#### 교착 상태 회피
프로세스들에 배분할 수 있는 자원의 양을 고려하여 <span style="color:rgb(218, 195, 137)">교착 상태가 발생하지 않을 정도의 양만큼만 자원을 배분</span>하는 방법이다.
- 안전 순서열(safe sequence)
  교착 상태 없이 안전하게 프로세스들에 자원을 할당할 수 있는 순서를 의미한다.
- 안정 상태(safe state)
  교착 상태가 발생하지 않고 모든 프로세스가 정상적으로 자원을 할당받고 종료될 수 있는 상태를 말한다.
  즉, 안전 순서열대로 프로세스들에 자원을 배분하여 교착 상태가 발생하지 않는 상태이다.
- 불안정 상태(unsafe state)
  교착 상태가 발생할 수도 있는 상황을 말한다.
  즉, 안전 순서열이 없는 상황이다.

교착 상태를 ==한정된 자원의 무분별한 할당으로 인해 발생하는 문제로 간주==한다.
프로세스들에 할당할 수 있는 자원이 충분한 상황에서 프로세스들이 한두 개의 적은 자원만을 요구한다면 교착 상태는 발생하지 않는다.
반면 프로세스들에 할당할 수 있는 자원이 한정된 상황에서 모든 프로세스들이 한 번에 많은 자원을 요구하면 교착 상태가 발생할 위험이 증가한다.

아래와 같은 상황에서 각 프로세스들이 모두 최대로 자원을 요구한 최악의 상황이라고 가정한다.
```tx
| 프로세스 | 요구량 | 현재 사용량 |
| --- | --- | --- |
| P1 | 10 | 5 |
| P2 | 4 | 2 |
| P3 | 9 | 2 |
```
할당 가능 자원: 12
남은 자원: 3
> [!note]- P2 -> P1 -> P3이라는 안전 순서열이 있으면 이 상태는 안전 상태이다.
> P2는 이미 자원 2개를 가지고 있으므로 남은 자원에서 2개를 배분하면 된다.
> 4개의 자원을 할당받은 P2는 정상적으로 작업을 끝내고 가지고 있던 자원을 반환한다.
> 이번에는 P1에 남은 자원 5개를 할당하면 P1 또한 작업을 정상적으로 완료할 수 있다.
> P1이 작업을 정상적으로 마치고 자원을 반환하면 이제 P3에 자원을 할당하면 된다.

위 상황과 동일한 상황에서 P3에 자원을 하나 더 내주었다고 가정한다.
```tx
| 프로세스 | 요구량 | 현재 사용량 |
| --- | --- | --- |
| P1 | 10 | 5 |
| P2 | 4 | 2 |
| P3 | 9 | 3 |
```
할당 가능 자원: 12
남은 자원: 2
> [!note]- 이 상태는 불안전 상태이다. 즉, 교착 상태가 발생할 위험이 있다.
> P2에 2개의 작업을 배분하여 P2 작업을 올바르게 끝낸다고 해도, P2 작업 이후 반환된 자원 4개로는 P1, P3의 요구를 들어줄 수 없다.

운영체제가 교착 상태를 회피하기 위해서는 시스템 상태가 안전 상태에서 안전 상태로 움직이는 경우에는 자원을 할당하면 된다.
즉, 교착 상태 회피 방식은 <span style="color:rgb(218, 195, 137)">항상 안전 상태를 유지하도록 자원을 할당</span>하는 방식이다.


#### 교착 상태 검출 후 회복
교착 상태 발생을 인정하고 사후에 조치하는 방식이다.
운영체제는 프로세스들이 자원을 요구할 떄마다 모두 할당하며, 교착 상태 발생 여부를 주기적으로 검사한다.

##### 선점을 통한 회복
교착 상태가 해결될 때까지 <span style="color:rgb(218, 195, 137)">다른 프로세스로부터 자원을 강제로 빼앗고 한 프로세스에 할당</span>하는 방식이다.

##### 프로세스 강제 종료를 통한 회복
운영체제는 <span style="color:rgb(218, 195, 137)">교착 상태에 놓인 프로세스를 모두 강제 종료</span>할 수 있다.
가장 확실한 방식이지만 그만큼 많은 프로세스들이 ==작업 내역을 읽게 될 가능성==이 있다.

교착 상태가 없어질 때까지 <span style="color:rgb(218, 195, 137)">한 프로세스씩 강제 종료</span>할 수도 있다.
작업 내역을 잃는 프로세스를 최대한 줄일 수 있지만, ==교착 상태가 없어졌는지 여부를 확인하는 과정에서 오버헤드==를 야기한다.

#### 교착 상태 무시
드물게 발생하는 잠재적 문제를 무시로 대처하는 방식으로 타조 알고리즘(ostrich algorithm)이 있다.
문제 발생의 빈도나 심각성에 따라 최대 효율을 추구하는 입장에서는 때때로 이 방식이 적합할 때도 많다.