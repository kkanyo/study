---
tags:
  - operating_system
---
협력하여 실행되는 프로세스들은 실행 순서와 자원의 일관성을 보장해야 하기에 반드시 동기화(synchronization)되어야 한다.

프로세스 동기화란 프로세스들 사이의 수행 시기를 맞추는 것을 의미한다.
- 실행 순서 제어: 프로세스를 올바른 순서대로 실행하기
- 상호 배제: 동시에 접근해서는 안 되는 자원에 하나의 프로세스만 접근하게 하기
> [!note] 
> 프로세스뿐만 아니라 스레드도 동기화 대상이다. 정확히 말하면 실행의 흐름을 갖는 모든 것은 동기화의 대상이다.

상호 배제(mutual exclusion)는 공유가 불가능한 자원의 동시 사용을 피하기 위해 사용하는 알고리즘이다.

***
### 생산자와 소비자 문제

``` 
총합 = 10

생산자 () {
	버퍼에 데이터 삽입
	'총합' 변수 1 증가
}

소비자 () {
	버퍼에서 데이터 빼내기
	'총합' 변수 1 감소
}
```
위와 같은 상태에서 생산자를 100,000번, 소비자를 100,000번 동시에 실행해 본다고 가정한다.
총합 변수가 10개로 머물러 있을 것으로 기대하지만, 실제로 실행해보면 예상치 못한 결과를 받을 수 있다.
작업이 끝나기도 전에 총합을 수정했기 때문이다. 즉, 동시에 접근해서는 안 되는 자원에 동시에 접근했기에 발생하는 문제이다.

***
### 공유 자원과 임계 구역
공유 자원(shared resource)란 프로세스들이 공동으로 이용하는 변수, 파일 장치 등의 자원을 말한다.
임계 구역(critical section)이란 동시에 실행하면 문제가 발생하는 자원에 접근하는 코드 영역을 말한다.

잘못된 실행으로 인해 여러 프로세스가 동시 다발적으로 임계 구역의 코드를 실행하여 문제가 발생하는 경우를 경쟁 상태(race condition)이라고 한다.
경쟁 상태가 발생하면 데이터의 일관성이 깨지는 문제가 발생한다.
경쟁 상태가 발생하는 근본적인 이유는 컴퓨터가 고급 언어가 아닌 저급 언어를 실행하기 때문이다.
여러 줄의 저급 언어로 변환된 고급 언어 한 줄을 실행하는 과정에서 문맥 교환이 일어나면 경쟁 상태가 발생할 수 있다.
![[os_synchronization_race-condition.png]]
이때, 상호 배제를 위한 동기화는 이와 같은 일이 발생하지 않도록 두 개 이상의 프로세스가 임계 구역에 동시에 접근하지 못하도록 관리하는 것을 의미한다.

운영체제는 임계 구역 문제를 아래 세 가지 원칙 하에 해결한다. 달리 말해 상호 배제를 위한 동기화를 위해서는 세 가지 원칙이 반드시 지켜져야만 한다.
- 상호 배제(mutual exclusion): 한 프로세스가 임계 구역에 진입했다면 다른 프로세스는 임계 구역에 들어올 수 없다.
- 진행(progress): 임계 구역에 어떤 프로세스도 진입하지 않았다면 임계 구역에 진입하고자 하는 프로세스는 들어갈 수 있어야 한다.
- 유한 대기(bounded waiting): 한 프로세스가 임계 구역에 진입하고 싶다면 그 프로세스는 언젠가는 임계 구역에 들어올 수 있어야 한다.

***
### 동기화 기법

#### 뮤텍스 락(Mutex lock: MUTual EXclusion lock)
동시에 접근해서는 안 되는 자원에 동시에 접근하지 않도록 만드는 도구, 즉 상호 배제를 위한 동기화 도구를 말한다.
뮤텍스 락은 하나의 공유 자원에 접근하는 프로세스를 상정한 방식이다.
매수 단순한 형태는 하나의 전역 변수와 두 개의 함수로 구현할 수 있다.
- 전역 변수 lock: 프로세스들이 공유하는 ==자물쇠 역할==을 한다.
- acquire 함수: 임계 구역을 ==잠그는 역할==을 한다. 
- release 함수: 입계 구역의 ==잠금을 해제==하는 역할을 한다.

acquire 함수는 프로세스가 임계 구역에 진입하기 전에 호출하는 함수이다.
임계 구역이 열릴 때까지(lock이 false가 될 때까지) 임계 구역을 ==반복적으로 확인==하고, 임계 구역이 열려 있다면 <span style="color:rgb(218, 195, 137)">임계 구역을 잠그는(lock을 true로 바꾸는) 함수</span>이다.
```c++
acquire() {
	while (lock == true)
		;
	lock = true;
}
```
임계 구역이 잠겨 있는지 <span style="color:rgb(218, 195, 137)">반복적으로 확인</span>하는 대기 방식을 <span style="color:rgb(218, 195, 137)">바쁜 대기(busy wait)</span>이라고 한다.

release 함수는 임계 구역에서의 작업이 끝나고 호출하는 함수이다.
현재 잠긴 <span style="color:rgb(218, 195, 137)">임계 구역을 열어 주는(lock을 false로 바꾸는) 함수</span>이다.
```c++
release() {
	lock = false;
}
```

acquire와 release 함수를 임계 구역 전후로 호출함으로써 ==하나의 프로세스만 임계 구역에 진입==할 수 있다.
```c++
acquire();
// Critical section
release();
```


#### 세마포(semaphore)
뮤텍스 락과 비슷하지만, 조금 더 일반화된 방식의 동기화 도구이다.
세마포는 <span style="color:rgb(218, 195, 137)">공유 자원이 여러 개 있는 상황에서도 적용이 가능한 동기화 도구</span>이다.

> [!info]- 세마포의 종류
> 이진 세마포(binary semaphre)와 카운팅(counting semaphore)가 있지만, 이진 세마포는 뮤텍스 락과 비슷한 개념이다.

세마포는 뮤텍스 락과 비슷하게 하나의 변수와 두 개의 함수로 단순하게 구현할 수 있다.
- 전역 변수 S: 임계 구역에 진입할 수 있는 ==프로세스의 개수(사용 가능한 공유 자원의 개수)==를 나타낸다.
- wait 함수: 임계 구역에 들어가도 좋은지, 기다려야 할지를 알려준다.
- signal 함수: 임계 구역 앞에서 기다리는 프로세스에게 진입 가능 신호를 준다.

> [!note]- 세마포 변수와 함수 이름
> 변수 이름과 함수 이름은 전공서마다 다를 수 있다. 
> 일부 전공서에서는 세마포를 처음 개발한 네덜란드의 컴퓨터 과학자인 에츠허르 다익스트라(Edsher W. Dijkstra)의 모국어에 근거해 wait과 signal 함수를 P, V로 명명하기도 하고, 철도 신호기에 근거해 down, up으로 부르기도 한다.
> 변수와 함수를 어떻게 지칭하든지 원리와 작동 방식은 모두 동일하다.

##### 상호 배제를 위한 동기화
세마포도 임계 구역 전후로 wait() 함수와 sinal() 함수를 호출한다.
```c++
wait();
// 임계 구역
signal();
```

변수 S는 임계 구역에 진입할 수 있는 프로세스의 개수, 혹은 사용 가능한 공유 자원의 개수임을 고려하여 wait 함수와 signal 함수는 다음과 같이 만든다.
```c++
wait() {
	while (S < = 0)
		;
	S--;
}

signal() {
	S++;
}
```
하지만 뮤텍스 락와 동일하게 사용할 수 있는 공유 자원이 없는 경우 프로세스는 무작정 무한히 반복하며 S를 확인해야 한다. ==(바쁜 대기)==
CPU 주기를 낭비한다는 점에서 손해이다.

그래서 실제로 세마포에서 wait 함수는 만일 사용할 수 있는 자원이 없을 경우 ==해당 프로세스 상태를 대기 상태로 만들고, 그 프로세스의 PCB를 세마포를 위한 대기 큐에 집어 넣는다.==
그리고 signal 함수는 대기 중인 프로세스를 대기 큐에서 제거하고, 프로세스 상태를 준비 상태로 변경한 뒤 준비 큐로 옮겨준다.
```c++
wait() {
	S--;
	if (S < 0) {
		// add thid process to Queue;
		sleep();
	}
}

signal() {
	S++;
	If (S <= 0) {
		// remove a process p from Queue
		wakeup(p);
	}
}
```

##### 실행 순서 제어를 위한 동기화
세마포의 변수 ==S를 0으로 두고 먼저 실행할 프로세스 뒤에 signal 함수, 다음에 실행할 프로세스 앞에 wait 함수==를 붙이면 된다.
```c++
/* ---- Process 1 ---- */
// Critical section
signal();

/* ---- Process 2 ---- */
wait();
// Critinal section
```


#### 모니터(monitor)
세마포는 매번 임계 구역에 앞뒤로 일일이 wait()와 signal() 함수를 명시하는 것이 번거롭다.
잘못된 코드로 인해 예기치 못한 결과를 얻을 수도 있다. (세마포를 누락한 경우, 순서를 헷갈린 경우, 중복해서 사용한 경우 등)

모니터는 공유 자원과 공유 자원에 접근하기 위한 ==인터페이스를 묶어 관리==한다.
그리고 ==프로세스는 반드시 인터페이스를 통해서만 공유자원에 접근==하도록 한다.
공유 자원에 접근하고자 하는 프로세스를 큐에 삽입하고, 큐에 삽입된 순서대로 하나씩 공유 자원을 이용하도록 한다.
즉, <span style="color:rgb(218, 195, 137)">공유 자원을 다루는 인터페이스에 접근하기 위한 큐(모니터에 진입하기 위한 큐)를 만들고, 모니터 안에 항상 하나의 프로세스만 들어오도록</span> 하여 상호 배제를 위한 동기화를 제공한다.
![[os_synchronization_monitor.png]]

세마포와 마찬가지로 실행 순서 제어를 위한 동기화도 제공한다.
<span style="color:rgb(218, 195, 137)">프로세스나 스레드의 실행 순서를 제어하기 위해 사용</span>하는 특별한 변수인 조건 변수(condition variable)를 사용하여 특정 조건에서 프로세스를 실행하고 일시 중단한다.

> [!note] 조건 변수와 모니터는 별개의 개념이다.

![[os_synchronization_monitor_condition-variable.png]]
조건 변수의 wait() 함수는 <span style="color:rgb(218, 195, 137)">호출한 프로세스의 상태를 대기 상태로 전환하고 일시적으로 조건 변수에 대한 대기 큐에 삽입</span>하는 연산이다.
조건 변수에 대한 큐에 삽입되면 모니터는 다시 비게 되므로 다른 프로세스가 모니터 안에 들어올 수 있게 된다.
대기 상태의 프로세스는 다른 프로세스의 signal 연산을 통해 실행이 재개될 수 있다. 즉, signal은 <span style="color:rgb(218, 195, 137)">wait() 함수를 호출하여 큐에 삽입된 프로세스의 실행을 재개</span>하는 연산이다.

정리하자면 특정 프로세스가 아직 실행될 조건이 되지 않았을 때에는 wait을 통해 실행을 중단한다.
특정 프로세스가 실행될 조건이 충족되었을 떄에는 signal을 통해 실행을 재개한다.


