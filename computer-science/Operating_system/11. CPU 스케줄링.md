---
tags:
  - operating_system
---
운영체제가 프로세스들에게 공정하고 합리적으로 CPU 자원을 배분하는 것을 말한다.

### 프로세스 우선순위
우선순위가 높은 프로세스에는 대표적으로 입출력 작업이 많은 프로세스가 있다.
> [!question]-  입출력 작업이 많은 프로세스를 먼저 실행하는 것이 왜 더 효율적일까?
프로세스는 실행 상태와 대기 상태를 반복하며 실행된다. ([[10. 프로세스와 스레드#프로세스 상태]])
그런데 프로세스 종류마다 입출력 장치와 CPU를 각각 이용하는 시간의 양에는 차이가 있다. 입출력이 많은 프로세스를 입출력 집중 프로세스(I/O bound process)라고 하고, CPU 작업이 많은 프로세스는 CPU 집중 프로세스(CPU bound process)라고 한다.
> >[!info] CPU 버스트와 입출력 버스트
> CPU를 이용하는 작업을 CPU 버스트(CPU burst)라 하고, 입출력장치를 기다리는 작업을 입출력 버스트(I/O burst)라고 부른다.
>
> >[!example]- 예시
> >  CPU 집중 프로세스와 입출력 집중 프로세스가 동시에 CPU 자원을 요구했다고 가정한다.
> >  입출력장치가 입출력 작업을 완료하기 전까지는 입출력 집중 프로세스는 어차피 대기 상태가 될 예정이므로 입출력 집중 프로세스를 얼른 먼저 처리해 버리면 다른 프로세스가 CPU를 사용할 수 있기 때문에 효율적이다.

운영체제는 각 프로세스의 PCB에 우선순위를 명시하고, PCB에 적힌 우선순위를 기준으로 먼저 처리할 프로세스를 결정한다.
> [!info]- 프로세스 우선순위 직접 확인하기
> 유닉스 체계 운영체제에서는 ps -el 명령을 통해 확인이 가능하며, nice 명령을 통해 일부 프로세스의 우선순위를 변경할 수 있다.
> 윈도우에서는 Process Explorer 소프트웨어를 통해 우선순위 확인과 변경이 가능하다.

***
### 스케줄링 큐(Scheduling queue)
운영체제가 모든 프로세스의 PCB를 방문하여 탐색하는 것은 비효율적이다.
운영체제는 프로세스들을 스케줄링 큐로 줄 세우기를 구현하고 관리한다.
> [!note] 
> 스케줄링에서 이야기하는 큐는 반드시 선입선출(First In First Out) 방식일 필요는 없다.

준비 큐(ready queue)는 CPU를 이용하고 싶은 프로세스들이 서는 줄을 의미하고, 대기 큐(waiting queue)는 입출력장치를 이용하기 위해 대기 상태에 접어든 프로세스들이 서는 줄을 의미한다.

프로세스들의 PCB는 큐의 마지막에 삽입되어 자원을 사용할 차례를 기다린다.
운영체제는 큐에 삽입된 순서대로 프로세스를 하나씩 꺼내어 실행하되, 우선순위가 높은 프로세스를 먼저 실행한다.
우선순위가 낮은 프로세스들이 먼저 큐에 삽입되어 줄을 섰다고 할지라도 우선순위가 높은 플도세스가 먼저 처리될 수 있다.

***
### 선점형과 비선점형 스케줄링

##### 선점형 스케줄링(preemptive scheduling)
프로세스가 CPU를 비롯한 자원을 사용하고 있더라도 운영체제가 프로세스로부터 자원을 강제로 빼앗아 다른 프로세스에 할당할 수 있는 스케줄링 방식을 의미한다.
어느 하나의 프로세스가 ==자원 사용을 독점할 수 없는== 스케줄링 방식이다.

프로세스들에 골고루 자원을 분배할 수 있다는 장점이 있지만, 그만큼 문맥 교환 과정에서 오버헤드가 발생할 수 있다.

##### 비선점형 스케줄링(non-preemtive scheduling)
하나의 프로세스가 자원을 사용하고 있다면 그 프로세스가 종료되거나 스스로 대기 상태에 접어들기 전까진 다른 프로세스가 끼어들 수 없는 스케줄링 방식을 의미한다.
하나의 프로세스가 ==자원 사용을 독점할 수 있는== 스케줄링 방식이다.

오버헤드는 선점형 스케줄링보다 적지만, 모든 프로세스가 골고루 자원을 사용할 수 없다는 단점이 있다.

***
### CPU 스케줄링 알고리즘
운영체제는 각자 서로 다른 스케줄링 알고리즘을 사용하고 있다.
중요한 것은 각 스케줄링 알고리즘에서 사용되는 '아이디어'이므로 작동 방식과 장단점을 이해하는 것이다.

#### <span style="color:rgb(218, 195, 137)">선입 선처리 스케줄링(First Come First Served Scheduling, FCFS)</span>
CPU를 먼저 요청한 프로세스부터 CPU를 할당하는 스케줄링 방식이다. 즉, 단순히 <span style="color:rgb(218, 195, 137)">준비 큐에 삽입된 순서대로</span> 프로세스들을 처리하는 ==비선점형 스케줄링 방식==이다.

CPU를 오래 사용하는 프로세스가 먼저 도착하면 다른 플도세스는 그 프로세스가 CPU를 사용하는 ==긴 시간 동안 무작정 기다리는== 수 밖에 없다. 이러한 현상을 호위 효과(convoy effect)라고 한다.

#### <span style="color:rgb(218, 195, 137)">최단 작업 우선 스케줄링(Shortest Job First Scheduling, SJF)</span>
CPU <span style="color:rgb(218, 195, 137)">이용 시간의 길이가 가장 짧은</span> 프로세스부터 실행하는 스케줄링 방식이다.
==기본적으로 비선점형 스케줄링 알고리즘==으로 분류하지만, 선점형으로 구현될 수도 있다.

#### <span style="color:rgb(218, 195, 137)">라운드 로빈 스케줄링(round robin scheduling)</span>
선입 선처리 스케줄링에 타임 슬라이스 개념이 더해진 스케줄링 방식이다.
<span style="color:rgb(218, 195, 137)">정해진 타임 슬라이스만큼</span>[^1]의 시간 동안 돌아가며 CPU를 이용하는 ==선점형 스케줄링==이다.

정해진 시간을 모두 사용하였음에도 아직 프로세스가 완료되지 않았다면 다시 큐의 맨 뒤에 삽입되는데, 이떄 문맥 교환이 발생한다.
따라서 타임 슬리스 크기가 매우 중요하다.
지나치게 크면 선입 선처리 스케줄링과 다를 바 없어 호위 효과가 생길 여지가 있고, 지나치게 작으면 문맥 교환이 발생하는 비용이 커진다.

#### <span style="color:rgb(218, 195, 137)">최소 잔여 시간 우선 스케줄링(Shortest Remaining Time Scheduling, SRT)</span>
최단 작업 우선 스케줄링 알고리즘와 라운드 로빈 알고리즘을 합친 스케줄링 방식이다.
<span style="color:rgb(218, 195, 137)">정해진 타임 슬라이스만큼</span> CPU를 사용하되, <span style="color:rgb(218, 195, 137)">남아있는 작업 시간이 가장 적은</span> 프로세스가 선택된다.

#### <span style="color:rgb(218, 195, 137)">우선순위 스케줄링(priority scheduling)</span>
프로세스들에 우선순위를 부여하고, <span style="color:rgb(218, 195, 137)">가장 높은 우선순위</span>를 가진 프로세스부터 실행하는 스케줄링 알고리즘이다.
==우선순위가 같은 프로세스들은 선입 선처리==로 스케줄링된다.
앞서 설명한 최단 우선 스케줄링, 최소 잔여 시간 우선 스케줄링 알고리즘은 넓은 의미에서 우선순위 스케줄링의 일종으로 볼 수 있다.

우선순위가 높은 프로세스들에 의해 <span style="color:rgb(218, 195, 137)">실행이 계속해서 연기</span>될 수 있는데, 이를 <span style="color:rgb(218, 195, 137)">기아(starvation) 현상</span>이라고 한다.
우선순위가 낮은 프로세스의 실행은 계속 뒤로 밀리는 것이다.

이를 방지하기 위한 대표적인 기법으로 <span style="color:rgb(218, 195, 137)">에이징(aging)</span>이 있는데, <span style="color:rgb(218, 195, 137)">오랫동한 대기한 프로세스의 우선순위를 점차 높이는</span> 방식이다.

#### <span style="color:rgb(218, 195, 137)">다단계 큐 스케줄링(multilevel queue scheduling)</span>
<span style="color:rgb(218, 195, 137)">우선순위별로 준비 큐를 여러 개</span> 사용하는 스케줄링 방식이다.
우선순위가 가장 높은 큐에 있는 프로세스들을 먼저 처리하고, 비어 있으면 그 다음 우선순위 큐에 있는 프로세스들을 처리한다.
프로세스들이 큐 사이를 이동할 수 없다. 즉, 기아 현상이 발생할 수 있다.

큐별로 타임 슬라이스를 여러 개 지정할 수 있고, 큐마다 다른 스케줄링 알고리즘을 사용할 수도 있다.

#### <span style="color:rgb(218, 195, 137)">다단계 피드백 큐 스케줄링(multilevel feedback queue scheduling)
</span>
프로세스의 <span style="color:rgb(218, 195, 137)">CPU 이용 시간이 길면 낮은 우선순위 큐로 이동</span>시키고, <span style="color:rgb(218, 195, 137)">낮은 우선순위 큐에서 너무 오래 기다리면 높은 우선순위 큐로 이동</span>시킬 수 있는 알고리즘이다.
새로 준비 상태가 된 프로세스가 있다면 우선 우선수위가 가장 높은 우선순위 큐에 삽입되고 ==일정 시간(타입 슬라이스)동안 실행==된다.
만약 실행이 끝나지 않는다면 다음 우선순위 큐에 삽입되어 실행된다. 즉, CPU를 오래 사용해야 하는 프로세스는 점차 우선순위가 낮아진다.

낮은 우선순위 큐에서 너무 오래 기다리고 있는 프로세스가 있다면 점차 우선순위가 높은 큐로 이동시키는 에이징 기법을 적용하여 기아 현상을 예방할 수 있다.

구현이 복잡하지만, 가장 일반적인 CPU 스케줄링 알고리즘으로 알려져 있다.

[^1]: 각 프로세스가 CPU를 사용할 수 있는 정해진 시간을 의미한다.